'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var option = require('./option.js');
var functions = require('./functions.js');
var observable = require('./observable.js');
var disposable = require('./disposable.js');
var scheduler$1 = require('./scheduler.js');
var react = require('react');
var scheduler = require('scheduler');

/**
 * Returns the current value, if defined, of `observable`.
 *
 * @param observable The `ObservableLike` to subscribe to.
 * @param scheduler An optional scheduler used when subscribing to `observable`. The default
 * is React's normal priority scheduler.
 */
const useObservable = (observable$1, options = {}) => {
    const { scheduler = normalPriority } = options;
    const [state, updateState] = react.useState(option.none);
    const [error, updateError] = react.useState(option.none);
    react.useEffect(() => {
        const subscription = functions.pipe(observable$1, observable.subscribe(scheduler, functions.compose(functions.returns, updateState)));
        disposable.addTeardown(subscription, functions.compose(functions.returns, updateError));
        return functions.defer(subscription, disposable.dispose());
    }, [observable$1, updateState, updateError, scheduler]);
    if (option.isSome(error)) {
        const { cause } = error;
        throw cause;
    }
    return state;
};
const createReplaySubject = () => observable.createSubject({ replay: 1 });
const createComponent = (fn) => {
    const ObservableComponent = (props) => {
        var _a;
        const propsSubject = react.useMemo(createReplaySubject, [
            createReplaySubject,
        ]);
        propsSubject.dispatch(props);
        const elementObservable = react.useMemo(() => functions.pipe(propsSubject, observable.distinctUntilChanged(), fn), [propsSubject]);
        return (_a = useObservable(elementObservable)) !== null && _a !== void 0 ? _a : null;
    };
    return ObservableComponent;
};
const priorityScheduler = {
    inContinuation: false,
    get now() {
        return scheduler.unstable_now();
    },
    get shouldYield() {
        return priorityScheduler.inContinuation && scheduler.unstable_shouldYield();
    },
    schedule(continuation, { priority, delay = 0, }) {
        const callback = () => {
            functions.pipe(callbackNodeDisposable, disposable.dispose());
            priorityScheduler.inContinuation = true;
            scheduler$1.run(continuation);
            priorityScheduler.inContinuation = false;
        };
        const callbackNode = scheduler.unstable_scheduleCallback(priority, callback, delay > 0 ? { delay } : option.none);
        const callbackNodeDisposable = disposable.createDisposable(functions.defer(callbackNode, scheduler.unstable_cancelCallback));
        disposable.addDisposable(continuation, callbackNodeDisposable);
    },
};
/** Scheduler that schedules work on React's internal priority scheduler with idle priority. */
const idlePriority = functions.pipe(priorityScheduler, scheduler$1.toSchedulerWithPriority(scheduler.unstable_IdlePriority));
/** Scheduler that schedules work on React's internal priority scheduler with immediate priority. */
const immediatePriority = functions.pipe(priorityScheduler, scheduler$1.toSchedulerWithPriority(scheduler.unstable_ImmediatePriority));
/** Scheduler that schedules work on React's internal priority scheduler with normal priority. */
const normalPriority = functions.pipe(priorityScheduler, scheduler$1.toSchedulerWithPriority(scheduler.unstable_NormalPriority));
/** Scheduler that schedules work on React's internal priority scheduler with low priority. */
const lowPriority = functions.pipe(priorityScheduler, scheduler$1.toSchedulerWithPriority(scheduler.unstable_LowPriority));
/** Scheduler that schedules work on React's internal priority scheduler with user blocking priority. */
const userBlockingPriority = functions.pipe(priorityScheduler, scheduler$1.toSchedulerWithPriority(scheduler.unstable_UserBlockingPriority));

exports.createComponent = createComponent;
exports.idlePriority = idlePriority;
exports.immediatePriority = immediatePriority;
exports.lowPriority = lowPriority;
exports.normalPriority = normalPriority;
exports.useObservable = useObservable;
exports.userBlockingPriority = userBlockingPriority;
