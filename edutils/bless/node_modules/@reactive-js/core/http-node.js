'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var option = require('./option.js');
var functions = require('./functions.js');
var observable = require('./observable.js');
var disposable = require('./disposable.js');
var streamable = require('./streamable.js');
var http = require('./http.js');
var node = require('./node.js');

const writeToServerResponse = (serverResponse) => {
    const responseBody = node.createWritableIOSink(functions.returns(serverResponse));
    return (response) => observable.defer(observer => () => {
        serverResponse.value.statusCode = response.statusCode;
        http.writeHttpResponseHeaders(response, (header, value) => serverResponse.value.setHeader(header, value));
        serverResponse.value.flushHeaders();
        const sinkSubscription = functions.pipe(streamable.sink(response.body, responseBody), observable.subscribe(observer));
        observer.add(sinkSubscription);
        observer.notify(option.none);
    });
};
const defaultOnError = (e) => {
    console.log(e);
};
const createHttpRequestListener = (handler, scheduler, options = {}) => {
    const { onError = defaultOnError } = options;
    const handleRequest = (request, serverResponse) => {
        var _a;
        const { method, url: uri = "/", headers, httpVersionMajor, httpVersionMinor, } = request.value;
        const isTransportSecure = (_a = request.value.socket.encrypted) !== null && _a !== void 0 ? _a : false;
        const requestBody = node.createReadableIOSource(functions.returns(request));
        const requestOptions = {
            method: method,
            uri,
            headers: headers,
            httpVersionMajor,
            httpVersionMinor,
            isTransportSecure,
            body: requestBody,
        };
        const writeResponse = (response) => option.isSome(response)
            ? functions.pipe(response, writeToServerResponse(serverResponse))
            : observable.empty();
        return functions.pipe(requestOptions, http.createHttpRequest, handler, observable.switchMap(writeResponse), observable.catchError(onError));
    };
    return (req, resp) => {
        const request = node.createDisposableNodeStream(req);
        const response = node.createDisposableNodeStream(resp);
        const handlerSubscription = functions.pipe(handleRequest(request, response), observable.subscribe(scheduler));
        disposable.addDisposable(handlerSubscription, request);
        disposable.addDisposable(response, handlerSubscription);
    };
};

const createContentEncodingDecompressTransforms = (options = {}) => ({
    ["br"]: node.brotliDecompress(options),
    ["deflate"]: node.deflate(options),
    ["gzip"]: node.gunzip(options),
});
const createContentEncodingCompressTransforms = (options = {}) => ({
    ["br"]: node.brotliCompress(options),
    ["deflate"]: node.inflate(options),
    ["gzip"]: node.gzip(options),
});

exports.createContentEncodingCompressTransforms = createContentEncodingCompressTransforms;
exports.createContentEncodingDecompressTransforms = createContentEncodingDecompressTransforms;
exports.createHttpRequestListener = createHttpRequestListener;
