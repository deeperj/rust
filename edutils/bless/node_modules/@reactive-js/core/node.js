'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var functions = require('./functions.js');
var observable = require('./observable.js');
var disposable = require('./disposable.js');
var streamable = require('./streamable.js');
var io = require('./io.js');
var fs = require('fs');
var zlib = require('zlib');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

function bindNodeCallback(callback) {
    return function (...args) {
        return observable.createObservable(dispatcher => {
            const handler = (cause, arg) => {
                if (cause) {
                    functions.pipe(dispatcher, disposable.dispose({ cause }));
                }
                else {
                    dispatcher.dispatch(arg);
                    functions.pipe(dispatcher, disposable.dispose());
                }
            };
            callback.apply(this, [...args, handler]);
        });
    };
}

const dispose = (writable) => {
    writable.removeAllListeners();
    // Calling destory can result in onError being called
    // if we don't catch the error, it crashes the process.
    // This kind of sucks, but its the best we can do;
    writable.once("error", functions.ignore);
    writable.once("close", () => {
        writable.removeAllListeners();
    });
    writable.destroy();
};
const createDisposableNodeStream = (stream) => {
    const retval = disposable.createDisposableValue(stream, dispose);
    stream.on("error", disposable.toErrorHandler(retval));
    return retval;
};

const createReadableEventsObservable = (readable) => observable.createObservable(dispatcher => {
    const readableValue = readable.value;
    const onData = functions.compose(io.notify, observable.dispatchTo(dispatcher));
    readableValue.on("data", onData);
    const onEnd = () => {
        dispatcher.dispatch(io.done());
        functions.pipe(dispatcher, disposable.dispose());
    };
    readableValue.on("end", onEnd);
    disposable.addDisposable(readable, dispatcher);
    disposable.addTeardown(dispatcher, _ => {
        readableValue.removeListener("data", onData);
        readableValue.removeListener("end", onEnd);
    });
});
const createReadableAndSetupModeSubscription = (factory, mode) => (scheduler) => {
    const readable = factory();
    const readableValue = readable.value;
    readableValue.pause();
    const modeSubscription = functions.pipe(mode, observable.subscribe(scheduler, ev => {
        switch (ev) {
            case "pause":
                readableValue.pause();
                break;
            case "resume":
                readableValue.resume();
                break;
        }
    }));
    disposable.addDisposableDisposeParentOnChildError(readable, modeSubscription);
    return readable;
};
const createReadableIOSource = (factory) => streamable.createStreamable(mode => observable.using(createReadableAndSetupModeSubscription(factory, mode), createReadableEventsObservable));
const readFileIOSource = (path, options) => createReadableIOSource(() => functions.pipe(fs__default['default'].createReadStream(path, options), createDisposableNodeStream));

const NODE_JS_PAUSE_EVENT = "__REACTIVE_JS_NODE_WRITABLE_PAUSE__";
const createWritableEventsObservable = (writable) => observable.createObservable(dispatcher => {
    const writableValue = writable.value;
    const onDrain = functions.defer("resume", observable.dispatchTo(dispatcher));
    writableValue.on("drain", onDrain);
    const onFinish = functions.defer(dispatcher, disposable.dispose());
    writableValue.on("finish", onFinish);
    const onPause = functions.defer("pause", observable.dispatchTo(dispatcher));
    writableValue.on(NODE_JS_PAUSE_EVENT, onPause);
    disposable.addDisposable(writable, dispatcher);
    disposable.addTeardown(dispatcher, _ => {
        writableValue.removeListener("drain", onDrain);
        writableValue.removeListener("finish", onFinish);
        writableValue.removeListener(NODE_JS_PAUSE_EVENT, onPause);
    });
    dispatcher.dispatch("resume");
});
const createWritableAndSetupEventSubscription = (factory, events) => (scheduler) => {
    const writable = factory();
    const writableValue = writable.value;
    const streamEventsSubscription = functions.pipe(events, observable.subscribe(scheduler, ev => {
        switch (ev.type) {
            case "notify":
                // FIXME: when writing to an outgoing node ServerResponse with a UInt8Array
                // node throws a type Error regarding expecting a Buffer, though the docs
                // say a UInt8Array should be accepted. Need to file a bug.
                if (!writableValue.write(Buffer.from(ev.data))) {
                    // Hack in a custom event here for pause request
                    writableValue.emit(NODE_JS_PAUSE_EVENT);
                }
                break;
            case "done":
                writableValue.end();
                break;
        }
    }));
    disposable.addDisposableDisposeParentOnChildError(writable, streamEventsSubscription);
    return writable;
};
const createWritableIOSink = (factory) => streamable.createStreamable(events => observable.using(createWritableAndSetupEventSubscription(factory, events), createWritableEventsObservable));

const transform = (factory) => src => streamable.createStreamable(modeObs => observable.using(scheduler => {
    const transform = factory();
    const transformSink = createWritableIOSink(
    // don't dispose the transform when the writable is disposed.
    () => {
        const disposable$1 = disposable.createDisposableValue(transform.value, functions.ignore);
        disposable.addOnDisposedWithError(disposable$1, transform);
        return disposable$1;
    });
    const transformReadableStream = functions.pipe(createReadableIOSource(functions.returns(transform)), streamable.stream(scheduler));
    const sinkSubscription = functions.pipe(streamable.sink(src, transformSink), observable.subscribe(scheduler));
    const modeSubscription = functions.pipe(modeObs, observable.subscribe(scheduler, transformReadableStream.dispatch, transformReadableStream));
    disposable.addDisposableDisposeParentOnChildError(transformReadableStream, sinkSubscription);
    disposable.addDisposableDisposeParentOnChildError(transformReadableStream, modeSubscription);
    return transformReadableStream;
}, functions.identity));
const brotliDecompress = (options = {}) => transform(functions.defer(options, zlib.createBrotliDecompress, createDisposableNodeStream));
const gunzip = (options = {}) => transform(functions.defer(options, zlib.createGunzip, createDisposableNodeStream));
const inflate = (options = {}) => transform(functions.defer(options, zlib.createInflate, createDisposableNodeStream));
const brotliCompress = (options = {}) => transform(functions.defer(options, zlib.createBrotliCompress, createDisposableNodeStream));
const gzip = (options = {}) => transform(functions.defer(options, zlib.createGzip, createDisposableNodeStream));
const deflate = (options = {}) => transform(functions.defer(options, zlib.createDeflate, createDisposableNodeStream));

exports.bindNodeCallback = bindNodeCallback;
exports.brotliCompress = brotliCompress;
exports.brotliDecompress = brotliDecompress;
exports.createDisposableNodeStream = createDisposableNodeStream;
exports.createReadableIOSource = createReadableIOSource;
exports.createWritableIOSink = createWritableIOSink;
exports.deflate = deflate;
exports.gunzip = gunzip;
exports.gzip = gzip;
exports.inflate = inflate;
exports.readFileIOSource = readFileIOSource;
exports.transform = transform;
