'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var functions = require('./functions.js');
var observable = require('./observable.js');
var disposable = require('./disposable.js');
var streamable = require('./streamable.js');
var flowable = require('./flowable.js');

const notify = (data) => ({
    type: "notify",
    data,
});
const _done = { type: "done" };
const done = () => _done;
const decodeWithCharset = (charset = "utf-8", options) => functions.pipe(observable.withLatestFrom(observable.compute()(() => new TextDecoder(charset, options)), function* (ev, decoder) {
    switch (ev.type) {
        case "notify": {
            const data = decoder.decode(ev.data, { stream: true });
            if (data.length > 0) {
                yield notify(data);
            }
            break;
        }
        case "done": {
            const data = decoder.decode();
            if (data.length > 0) {
                yield notify(data);
            }
            yield done();
            break;
        }
    }
}), functions.composeWith(observable.map(functions.returns)), functions.composeWith(observable.concatMap(observable.fromIterator())), streamable.lift);
const _encodeUtf8 = streamable.withLatestFrom(observable.compute()(() => new TextEncoder()), (ev, textEncoder) => {
    switch (ev.type) {
        case "notify": {
            const data = textEncoder.encode(ev.data);
            return notify(data);
        }
        case "done": {
            return ev;
        }
    }
});
const encodeUtf8 = _encodeUtf8;
const map = (mapper) => streamable.map((ev) => ev.type === "notify" ? functions.pipe(ev.data, mapper, notify) : ev);
const _fromObservable = functions.compose(observable.map(notify), observable.endWith(done()), flowable.fromObservable());
const fromObservable = () => _fromObservable;
const fromArray = (options) => functions.compose(observable.fromArray(options), fromObservable());
const fromValue = (options) => v => fromArray(options)([v]);
const _empty = fromArray()([]);
const empty = () => _empty;
const isNotify = (ev) => ev.type === "notify";
class IOSinkAccumulatorImpl extends disposable.AbstractDisposable {
    constructor(reducer, initialValue, options) {
        super();
        this.isSynchronous = false;
        const subject = observable.createSubject(options);
        disposable.addDisposableDisposeParentOnChildError(this, subject);
        const op = (events) => observable.using(scheduler => functions.pipe(events, observable.takeWhile(isNotify), observable.keepType(isNotify), observable.map(ev => ev.data), observable.reduce(reducer, initialValue), observable.subscribe(scheduler, subject.dispatch, subject)), eventsSubscription => observable.createObservable(dispatcher => {
            dispatcher.dispatch("pause");
            dispatcher.dispatch("resume");
            disposable.addDisposable(eventsSubscription, dispatcher);
        }));
        this.streamable = streamable.createStreamable(op);
        this.subject = subject;
    }
    get observerCount() {
        return this.subject.observerCount;
    }
    observe(observer) {
        this.subject.observe(observer);
    }
    stream(scheduler, options) {
        const result = functions.pipe(this.streamable, streamable.stream(scheduler, options));
        disposable.addDisposableDisposeParentOnChildError(this, result);
        return result;
    }
}
/** @experimental */
const createIOSinkAccumulator = (reducer, initialValue, options) => new IOSinkAccumulatorImpl(reducer, initialValue, options);

exports.createIOSinkAccumulator = createIOSinkAccumulator;
exports.decodeWithCharset = decodeWithCharset;
exports.done = done;
exports.empty = empty;
exports.encodeUtf8 = encodeUtf8;
exports.fromArray = fromArray;
exports.fromObservable = fromObservable;
exports.fromValue = fromValue;
exports.map = map;
exports.notify = notify;
