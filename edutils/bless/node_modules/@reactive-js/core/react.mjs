import { none, isSome } from './option.mjs';
import { pipe, compose, returns, defer } from './functions.mjs';
import { subscribe, createSubject, distinctUntilChanged } from './observable.mjs';
import { addTeardown, dispose, createDisposable, addDisposable } from './disposable.mjs';
import { run, toSchedulerWithPriority } from './scheduler.mjs';
import { useState, useEffect, useMemo } from 'react';
import { unstable_now, unstable_shouldYield, unstable_scheduleCallback, unstable_cancelCallback, unstable_IdlePriority, unstable_ImmediatePriority, unstable_NormalPriority, unstable_LowPriority, unstable_UserBlockingPriority } from 'scheduler';

/**
 * Returns the current value, if defined, of `observable`.
 *
 * @param observable The `ObservableLike` to subscribe to.
 * @param scheduler An optional scheduler used when subscribing to `observable`. The default
 * is React's normal priority scheduler.
 */
const useObservable = (observable, options = {}) => {
    const { scheduler = normalPriority } = options;
    const [state, updateState] = useState(none);
    const [error, updateError] = useState(none);
    useEffect(() => {
        const subscription = pipe(observable, subscribe(scheduler, compose(returns, updateState)));
        addTeardown(subscription, compose(returns, updateError));
        return defer(subscription, dispose());
    }, [observable, updateState, updateError, scheduler]);
    if (isSome(error)) {
        const { cause } = error;
        throw cause;
    }
    return state;
};
const createReplaySubject = () => createSubject({ replay: 1 });
const createComponent = (fn) => {
    const ObservableComponent = (props) => {
        var _a;
        const propsSubject = useMemo(createReplaySubject, [
            createReplaySubject,
        ]);
        propsSubject.dispatch(props);
        const elementObservable = useMemo(() => pipe(propsSubject, distinctUntilChanged(), fn), [propsSubject]);
        return (_a = useObservable(elementObservable)) !== null && _a !== void 0 ? _a : null;
    };
    return ObservableComponent;
};
const priorityScheduler = {
    inContinuation: false,
    get now() {
        return unstable_now();
    },
    get shouldYield() {
        return priorityScheduler.inContinuation && unstable_shouldYield();
    },
    schedule(continuation, { priority, delay = 0, }) {
        const callback = () => {
            pipe(callbackNodeDisposable, dispose());
            priorityScheduler.inContinuation = true;
            run(continuation);
            priorityScheduler.inContinuation = false;
        };
        const callbackNode = unstable_scheduleCallback(priority, callback, delay > 0 ? { delay } : none);
        const callbackNodeDisposable = createDisposable(defer(callbackNode, unstable_cancelCallback));
        addDisposable(continuation, callbackNodeDisposable);
    },
};
/** Scheduler that schedules work on React's internal priority scheduler with idle priority. */
const idlePriority = pipe(priorityScheduler, toSchedulerWithPriority(unstable_IdlePriority));
/** Scheduler that schedules work on React's internal priority scheduler with immediate priority. */
const immediatePriority = pipe(priorityScheduler, toSchedulerWithPriority(unstable_ImmediatePriority));
/** Scheduler that schedules work on React's internal priority scheduler with normal priority. */
const normalPriority = pipe(priorityScheduler, toSchedulerWithPriority(unstable_NormalPriority));
/** Scheduler that schedules work on React's internal priority scheduler with low priority. */
const lowPriority = pipe(priorityScheduler, toSchedulerWithPriority(unstable_LowPriority));
/** Scheduler that schedules work on React's internal priority scheduler with user blocking priority. */
const userBlockingPriority = pipe(priorityScheduler, toSchedulerWithPriority(unstable_UserBlockingPriority));

export { createComponent, idlePriority, immediatePriority, lowPriority, normalPriority, useObservable, userBlockingPriority };
