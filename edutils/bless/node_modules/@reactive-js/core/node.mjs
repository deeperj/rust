import { pipe, ignore, compose, defer, returns, identity } from './functions.mjs';
import { createObservable, dispatchTo, subscribe, using } from './observable.mjs';
import { dispose as dispose$1, createDisposableValue, toErrorHandler, addDisposable, addTeardown, addDisposableDisposeParentOnChildError, addOnDisposedWithError } from './disposable.mjs';
import { createStreamable, stream, sink } from './streamable.mjs';
import { notify, done } from './io.mjs';
import fs from 'fs';
import { createBrotliDecompress, createGunzip, createInflate, createBrotliCompress, createGzip, createDeflate } from 'zlib';

function bindNodeCallback(callback) {
    return function (...args) {
        return createObservable(dispatcher => {
            const handler = (cause, arg) => {
                if (cause) {
                    pipe(dispatcher, dispose$1({ cause }));
                }
                else {
                    dispatcher.dispatch(arg);
                    pipe(dispatcher, dispose$1());
                }
            };
            callback.apply(this, [...args, handler]);
        });
    };
}

const dispose = (writable) => {
    writable.removeAllListeners();
    // Calling destory can result in onError being called
    // if we don't catch the error, it crashes the process.
    // This kind of sucks, but its the best we can do;
    writable.once("error", ignore);
    writable.once("close", () => {
        writable.removeAllListeners();
    });
    writable.destroy();
};
const createDisposableNodeStream = (stream) => {
    const retval = createDisposableValue(stream, dispose);
    stream.on("error", toErrorHandler(retval));
    return retval;
};

const createReadableEventsObservable = (readable) => createObservable(dispatcher => {
    const readableValue = readable.value;
    const onData = compose(notify, dispatchTo(dispatcher));
    readableValue.on("data", onData);
    const onEnd = () => {
        dispatcher.dispatch(done());
        pipe(dispatcher, dispose$1());
    };
    readableValue.on("end", onEnd);
    addDisposable(readable, dispatcher);
    addTeardown(dispatcher, _ => {
        readableValue.removeListener("data", onData);
        readableValue.removeListener("end", onEnd);
    });
});
const createReadableAndSetupModeSubscription = (factory, mode) => (scheduler) => {
    const readable = factory();
    const readableValue = readable.value;
    readableValue.pause();
    const modeSubscription = pipe(mode, subscribe(scheduler, ev => {
        switch (ev) {
            case "pause":
                readableValue.pause();
                break;
            case "resume":
                readableValue.resume();
                break;
        }
    }));
    addDisposableDisposeParentOnChildError(readable, modeSubscription);
    return readable;
};
const createReadableIOSource = (factory) => createStreamable(mode => using(createReadableAndSetupModeSubscription(factory, mode), createReadableEventsObservable));
const readFileIOSource = (path, options) => createReadableIOSource(() => pipe(fs.createReadStream(path, options), createDisposableNodeStream));

const NODE_JS_PAUSE_EVENT = "__REACTIVE_JS_NODE_WRITABLE_PAUSE__";
const createWritableEventsObservable = (writable) => createObservable(dispatcher => {
    const writableValue = writable.value;
    const onDrain = defer("resume", dispatchTo(dispatcher));
    writableValue.on("drain", onDrain);
    const onFinish = defer(dispatcher, dispose$1());
    writableValue.on("finish", onFinish);
    const onPause = defer("pause", dispatchTo(dispatcher));
    writableValue.on(NODE_JS_PAUSE_EVENT, onPause);
    addDisposable(writable, dispatcher);
    addTeardown(dispatcher, _ => {
        writableValue.removeListener("drain", onDrain);
        writableValue.removeListener("finish", onFinish);
        writableValue.removeListener(NODE_JS_PAUSE_EVENT, onPause);
    });
    dispatcher.dispatch("resume");
});
const createWritableAndSetupEventSubscription = (factory, events) => (scheduler) => {
    const writable = factory();
    const writableValue = writable.value;
    const streamEventsSubscription = pipe(events, subscribe(scheduler, ev => {
        switch (ev.type) {
            case "notify":
                // FIXME: when writing to an outgoing node ServerResponse with a UInt8Array
                // node throws a type Error regarding expecting a Buffer, though the docs
                // say a UInt8Array should be accepted. Need to file a bug.
                if (!writableValue.write(Buffer.from(ev.data))) {
                    // Hack in a custom event here for pause request
                    writableValue.emit(NODE_JS_PAUSE_EVENT);
                }
                break;
            case "done":
                writableValue.end();
                break;
        }
    }));
    addDisposableDisposeParentOnChildError(writable, streamEventsSubscription);
    return writable;
};
const createWritableIOSink = (factory) => createStreamable(events => using(createWritableAndSetupEventSubscription(factory, events), createWritableEventsObservable));

const transform = (factory) => src => createStreamable(modeObs => using(scheduler => {
    const transform = factory();
    const transformSink = createWritableIOSink(
    // don't dispose the transform when the writable is disposed.
    () => {
        const disposable = createDisposableValue(transform.value, ignore);
        addOnDisposedWithError(disposable, transform);
        return disposable;
    });
    const transformReadableStream = pipe(createReadableIOSource(returns(transform)), stream(scheduler));
    const sinkSubscription = pipe(sink(src, transformSink), subscribe(scheduler));
    const modeSubscription = pipe(modeObs, subscribe(scheduler, transformReadableStream.dispatch, transformReadableStream));
    addDisposableDisposeParentOnChildError(transformReadableStream, sinkSubscription);
    addDisposableDisposeParentOnChildError(transformReadableStream, modeSubscription);
    return transformReadableStream;
}, identity));
const brotliDecompress = (options = {}) => transform(defer(options, createBrotliDecompress, createDisposableNodeStream));
const gunzip = (options = {}) => transform(defer(options, createGunzip, createDisposableNodeStream));
const inflate = (options = {}) => transform(defer(options, createInflate, createDisposableNodeStream));
const brotliCompress = (options = {}) => transform(defer(options, createBrotliCompress, createDisposableNodeStream));
const gzip = (options = {}) => transform(defer(options, createGzip, createDisposableNodeStream));
const deflate = (options = {}) => transform(defer(options, createDeflate, createDisposableNodeStream));

export { bindNodeCallback, brotliCompress, brotliDecompress, createDisposableNodeStream, createReadableIOSource, createWritableIOSink, deflate, gunzip, gzip, inflate, readFileIOSource, transform };
