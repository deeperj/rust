import { none, isSome } from './option.mjs';
import { returns, pipe } from './functions.mjs';
import { defer, subscribe, empty, switchMap, catchError } from './observable.mjs';
import { addDisposable } from './disposable.mjs';
import { sink } from './streamable.mjs';
import { writeHttpResponseHeaders, createHttpRequest } from './http.mjs';
import { createWritableIOSink, createReadableIOSource, createDisposableNodeStream, brotliDecompress, deflate, gunzip, brotliCompress, inflate, gzip } from './node.mjs';

const writeToServerResponse = (serverResponse) => {
    const responseBody = createWritableIOSink(returns(serverResponse));
    return (response) => defer(observer => () => {
        serverResponse.value.statusCode = response.statusCode;
        writeHttpResponseHeaders(response, (header, value) => serverResponse.value.setHeader(header, value));
        serverResponse.value.flushHeaders();
        const sinkSubscription = pipe(sink(response.body, responseBody), subscribe(observer));
        observer.add(sinkSubscription);
        observer.notify(none);
    });
};
const defaultOnError = (e) => {
    console.log(e);
};
const createHttpRequestListener = (handler, scheduler, options = {}) => {
    const { onError = defaultOnError } = options;
    const handleRequest = (request, serverResponse) => {
        var _a;
        const { method, url: uri = "/", headers, httpVersionMajor, httpVersionMinor, } = request.value;
        const isTransportSecure = (_a = request.value.socket.encrypted) !== null && _a !== void 0 ? _a : false;
        const requestBody = createReadableIOSource(returns(request));
        const requestOptions = {
            method: method,
            uri,
            headers: headers,
            httpVersionMajor,
            httpVersionMinor,
            isTransportSecure,
            body: requestBody,
        };
        const writeResponse = (response) => isSome(response)
            ? pipe(response, writeToServerResponse(serverResponse))
            : empty();
        return pipe(requestOptions, createHttpRequest, handler, switchMap(writeResponse), catchError(onError));
    };
    return (req, resp) => {
        const request = createDisposableNodeStream(req);
        const response = createDisposableNodeStream(resp);
        const handlerSubscription = pipe(handleRequest(request, response), subscribe(scheduler));
        addDisposable(handlerSubscription, request);
        addDisposable(response, handlerSubscription);
    };
};

const createContentEncodingDecompressTransforms = (options = {}) => ({
    ["br"]: brotliDecompress(options),
    ["deflate"]: deflate(options),
    ["gzip"]: gunzip(options),
});
const createContentEncodingCompressTransforms = (options = {}) => ({
    ["br"]: brotliCompress(options),
    ["deflate"]: inflate(options),
    ["gzip"]: gzip(options),
});

export { createContentEncodingCompressTransforms, createContentEncodingDecompressTransforms, createHttpRequestListener };
